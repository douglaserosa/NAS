/*
 * Copyright (c) 2010 Derrell Lipman
 * Parallel Kernel EP: An embarrassingly parallel benchmark
 * ZPL implementation
 */

program ep;


const
  INITIAL_SEED : double = 271828183;

  -- Pre-compute constants required for modulo-46 multiplication
  POW_2_N23 : double = pow(2, -23);
  POW_2_23  : double = pow(2,  23);
  POW_2_N46 : double = pow(2, -46);
  POW_2_46  : double = pow(2,  46);

var
  n      : integer = 2^28;


free var
  p      : integer = numLocales(); -- number of processes
  myRank : integer = localeID();   -- which process am I?
  seed   : double;                 -- current local seed

  -- This should be a const, but const isn't considered free. Sigh.
  MULT         : double = 5^13;    -- multiplier for pseudorandom generator


-- The algorithm requires pairs of values. They are stored in one of these.
type Pair = record
  x : double;
  y : double;
end;

-- The results of the EP worker are returned for printing in one of these.
type Results = record
  counts : array [0..9] of integer; -- counts of values in various ranges
  sums   : array [0..1] of double;  -- sumX in [0]; sumY in [1]
end;

------------------------------------------------------------------------------

/**
 * Find the maximum of two floating-point numbers.
 *
 * @param a
 *   The first of two numbers to be compared
 *
 * @param b
 *   The second of two numbers to be compared
 *
 * @return
 *   The floor of the maximum of the two parameter values.
 */
free procedure
maximum(free in a : double; free in b : double) : integer;

free var ret : double;
begin
  ret := b;
  if a >= b then
    ret := a;
  end;

  return to_integer(ret);
end;

------------------------------------------------------------------------------

/**
 * Multiple two floating point numbers, modulo 46.
 *
 * @param a
 *   The first of two numbers to be multiplied
 *
 * @param b
 *   The second of two numbers to be multiplied
 *
 * @return
 *   The modulo 46 product of the two parameter values.
 */
free procedure
multiplyModulo46(free in a : double; free in b : double) : double;

free var
  a1 : double = floor(POW_2_N23 * a);
  a2 : double = a - POW_2_23 * a1;
  b1 : double = floor(POW_2_N23 * b);
  b2 : double = b - POW_2_23 * b1;
  t1 : double = (a1 * b2) + (a2 * b1);
  t2 : double = floor(POW_2_N23 * t1);
  t3 : double = t1 - (POW_2_23 * t2);
  t4 : double = (2^23 * t3) + (a2 * b2);
  t5 : double = floor(POW_2_N46 * t4);

begin
  return t4 - (POW_2_46 * t5);
end;

------------------------------------------------------------------------------

/**
 * Calculate and return the next pseudo-random number.
 *
 * @side-effects
 *   The global value seed is set to be the seed for the random number of
 *   the next call to this function.
 *
 * @return
 *   The next pseudo-random number, as determined from the pre-existing seed.
 */
free procedure
pseudorandom() : double;

free var
  oldS : double;

begin
  -- Save the old seed as it's used to calculate the return value
  oldS := seed;

  -- Calculate the next seed
  seed := multiplyModulo46(MULT, seed);

  -- Calculate the return value based on the current seed
  return POW_2_N46 * oldS;
end;

------------------------------------------------------------------------------

/**
 * log base 2. ZPL is supposed to have a log2() function, but the compiler
 * complains. We want the floor of the logarithm, anyway.
 *
 * @param a
 *   The value for which a logarithm base 2, is desired.
 *
 * @return
 *   The floor of the log base 2 of the parameter value.
 */
free procedure
log2(free in a : double) : integer;

free var
  i : integer;

begin
  i := floor(log(a) / log(2));
  return i;
end;

------------------------------------------------------------------------------

/**
 * Get the seed for the kth pseudo-random number
 *
 * @param k
 *   The index of the pseudo-random number for which the seed is desired
 *
 * @return
 *   The seed for the random number at the index specified by the parameter.
 */
free procedure
getSeedFor(free in k : double) : double;

free var
  i : integer;
  j : integer;
  m : integer;
  b : double;
  t : double;

begin
  m := log2(k) + 1;
  b := INITIAL_SEED;
  t := MULT;

  for i := 1 to m
  do
    j := k / 2;
    if (2 * j != k) then
      b := multiplyModulo46(b, t);
    end;
    t := multiplyModulo46(t, t);
    k := j;
  end;

  return b;
end;

------------------------------------------------------------------------------

/**
 * Get a pair of random numbers, scaled to the range (-1, 1).
 *
 * @return
 *   A pair of pseudo-random numbers, each of which is in the range (-1, 1)
 */
free procedure
randomPair() : Pair;

free var
  pair : Pair;

begin
  pair.x := 2 * pseudorandom() - 1;
  pair.y := 2 * pseudorandom() - 1;

  return pair;
end;

------------------------------------------------------------------------------

/**
 * Implementation of the main EP loop, generating pairs of pseudorandom
 * numbers, deciding if they're acceptable, tracking counts, and calculating
 * sums. This procedure is itself not free, but makes use of many free
 * sub-procedures.
 *
 * @return
 *   A Results record which includes an array of ten counts, and an array of
 *   two sums.
 */
procedure ep_worker() : Results;

free var
  i        : integer;
  maxXY    : integer;
  pair     : Pair;
  t        : double;
  temp     : double;

  -- Local results: array of counts, and array of sums (of X and Y values).
  myResults: Results;

var
  -- Final results will be accumulated from all processes, here.
  results  : Results;

begin
  -- Initialize local results
  for i := 0 to 9
  do
    myResults.counts[i] := 0;
  end;
  myResults.sums[0] := 0.0;
  myResults.sums[1] := 0.0;

  -- For each random pair that this process is supposed to generate...
  for i := 1 to n / p
  do
    -- Generate a pair
    pair := randomPair();

    -- Is this pair acceptable? 
    t := pair.x^2 + pair.y^2;
    if (t > 1.0) then
      -- Nope. Reject 
      continue;
    end;

    -- Munge the pair as required by NAS EP
    temp := sqrt(-2 * log(t) / t);
    pair.x *= temp;
    pair.y *= temp;

    -- The sum of X values is placed in [0]; Y values in [1]
    myResults.sums[0] += pair.x;
    myResults.sums[1] += pair.y;

    -- We're told to use the maximum of absolute value of the two values 
    -- in the pair. Find that maximum, truncated to an integer.
    maxXY := maximum(fabs(pair.x), fabs(pair.y));

    -- Increment the appropriate count depending on the selected value
    myResults.counts[maxXY] += 1;
  end;

  -- Now that we have counts and sums in each process (in free variables),
  -- reduce those counts and sums into a parallel variable containing an index
  -- array so we have a global set of counts and sums.
  results.counts[] := +<< myResults.counts[];
  results.sums[] := +<< myResults.sums[];

  -- Give 'em our results!
  return results;
end;

------------------------------------------------------------------------------

/*
 * Main Program
 */
procedure ep();
var
  j        : integer;
  results  : Results;

begin
  -- Calculate the seed for the first random number in this local process
  seed := getSeedFor(myRank * (n / p) * 2 + 1);

  -- Start a fresh timer
  ResetTimer();

  -- Run the NAS EP process
  results := ep_worker();

  -- Tell 'em how long it took
  writeln("Total time in seconds: ", CheckTimer());

  --
  -- Display the results
  --
  writeln("l\tQt");
  writeln("---------------------\n");
  for j := 0 to 9
  do
    writeln(j, results.counts[j]);
  end;
  writeln("---------------------\n");

  writeln("sum(X) = ", results.sums[0]);
  writeln("sum(Y) = ", results.sums[1]);
  writeln("");
end;
